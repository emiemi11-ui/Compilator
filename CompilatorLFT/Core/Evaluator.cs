using System;
using System.Collections.Generic;
using CompilatorLFT.Models;
using CompilatorLFT.Models.Expressions;
using CompilatorLFT.Models.Statements;
using CompilatorLFT.Utils;
using ProgramNode = CompilatorLFT.Models.Statements.Program;

namespace CompilatorLFT.Core
{
    /// <summary>
    /// Evaluator for expressions and executor for statements.
    /// </summary>
    /// <remarks>
    /// Reference: Dragon Book, Ch. 5 - Syntax-Directed Translation
    /// Reference: Grigoraș "Proiectarea Compilatoarelor", Cap. 6.5
    /// Reference: Levine "Flex & Bison", Ch. 3
    ///
    /// Implements:
    /// - Tree-walking interpreter (Visitor Pattern for AST traversal)
    /// - Print statement (Grigoraș 6.5)
    /// - User-defined functions (Flex & Bison style)
    /// - Built-in functions (sqrt, abs, exp, log, etc.)
    /// - Logical operators with short-circuit evaluation (&&, ||, !)
    /// - Break/Continue statements
    /// - Return statements
    /// - Increment/decrement operators (++, --)
    /// - Compound assignment operators (+=, -=, *=, /=, %=)
    /// </remarks>
    public class Evaluator
    {
        #region Private Fields

        private readonly SymbolTable _symbolTable;
        private readonly List<CompilationError> _errors;
        private readonly List<string> _output;
        private readonly Dictionary<string, FunctionDeclaration> _functions;

        // Stack for function call contexts
        private readonly Stack<Dictionary<string, object>> _callStack;
        private bool _inLoop;

        // Constant for floating point comparison
        private const double EPSILON = 1e-10;

        // Limit for loops (to avoid infinite loops)
        private const int ITERATION_LIMIT = 100000;

        #endregion

        #region Control Flow Exceptions

        /// <summary>Exception for break statement.</summary>
        private class BreakException : Exception { }

        /// <summary>Exception for continue statement.</summary>
        private class ContinueException : Exception { }

        /// <summary>Exception for return statement.</summary>
        private class ReturnException : Exception
        {
            public object Value { get; }
            public ReturnException(object value) => Value = value;
        }

        #endregion

        #region Properties

        /// <summary>List of evaluation errors.</summary>
        public IReadOnlyList<CompilationError> Errors => _errors;

        /// <summary>Output generated by evaluation.</summary>
        public IReadOnlyList<string> Output => _output;

        #endregion

        #region Constructor

        /// <summary>
        /// Initializes the evaluator with the symbol table.
        /// </summary>
        /// <param name="symbolTable">Symbol table populated by parser</param>
        /// <param name="functions">User-defined functions</param>
        public Evaluator(SymbolTable symbolTable, Dictionary<string, FunctionDeclaration> functions = null)
        {
            _symbolTable = symbolTable ?? throw new ArgumentNullException(nameof(symbolTable));
            _functions = functions ?? new Dictionary<string, FunctionDeclaration>();
            _errors = new List<CompilationError>();
            _output = new List<string>();
            _callStack = new Stack<Dictionary<string, object>>();
            _inLoop = false;
        }

        #endregion

        #region Program Execution

        /// <summary>
        /// Executes the entire program.
        /// </summary>
        /// <param name="program">Program to execute</param>
        public void ExecuteProgram(ProgramNode program)
        {
            // Register user-defined functions
            foreach (var func in program.Functions)
            {
                _functions[func.Name.Text] = func;
            }

            // Execute all statements
            foreach (var statement in program.Statements)
            {
                try
                {
                    ExecuteStatement(statement);
                }
                catch (ReturnException)
                {
                    _errors.Add(CompilationError.Semantic(1, 1,
                        "return statement outside of function"));
                }
                catch (BreakException)
                {
                    _errors.Add(CompilationError.Semantic(1, 1,
                        "break statement outside of loop"));
                }
                catch (ContinueException)
                {
                    _errors.Add(CompilationError.Semantic(1, 1,
                        "continue statement outside of loop"));
                }
            }
        }

        /// <summary>
        /// Executes a statement.
        /// </summary>
        private void ExecuteStatement(Statement statement)
        {
            switch (statement)
            {
                case DeclarationStatement decl:
                    ExecuteDeclaration(decl);
                    break;

                case AssignmentStatement assign:
                    ExecuteAssignment(assign);
                    break;

                case CompoundAssignmentStatement compound:
                    ExecuteCompoundAssignment(compound);
                    break;

                case ExpressionStatement expr:
                    ExecuteStandaloneExpression(expr);
                    break;

                case PrintStatement print:
                    ExecutePrint(print);
                    break;

                case BreakStatement:
                    throw new BreakException();

                case ContinueStatement:
                    throw new ContinueException();

                case ReturnStatement ret:
                    ExecuteReturn(ret);
                    break;

                case ForStatement forStmt:
                    ExecuteFor(forStmt);
                    break;

                case WhileStatement whileStmt:
                    ExecuteWhile(whileStmt);
                    break;

                case IfStatement ifStmt:
                    ExecuteIf(ifStmt);
                    break;

                case BlockStatement block:
                    ExecuteBlock(block);
                    break;
            }
        }

        /// <summary>
        /// Executes a variable declaration.
        /// </summary>
        private void ExecuteDeclaration(DeclarationStatement decl)
        {
            var dataType = SymbolTable.ConvertToDataType(decl.TypeKeyword.Type);

            foreach (var (id, initExpr) in decl.Declarations)
            {
                if (initExpr != null)
                {
                    var value = EvaluateExpression(initExpr);

                    if (value != null)
                    {
                        var convertedValue = ConvertToType(value, dataType, id.Line, id.Column);

                        if (convertedValue != null)
                        {
                            _symbolTable.SetValue(
                                id.Text, convertedValue,
                                id.Line, id.Column, _errors);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Executes an assignment.
        /// </summary>
        private void ExecuteAssignment(AssignmentStatement assign)
        {
            var value = EvaluateExpression(assign.Expression);

            if (value != null)
            {
                var variable = _symbolTable.Get(assign.Identifier.Text);

                if (variable != null)
                {
                    var convertedValue = ConvertToType(
                        value, variable.Type,
                        assign.Identifier.Line, assign.Identifier.Column);

                    if (convertedValue != null)
                    {
                        _symbolTable.SetValue(
                            assign.Identifier.Text, convertedValue,
                            assign.Identifier.Line, assign.Identifier.Column,
                            _errors);
                    }
                }
            }
        }

        /// <summary>
        /// Executes a compound assignment (+=, -=, *=, /=, %=).
        /// </summary>
        private void ExecuteCompoundAssignment(CompoundAssignmentStatement stmt)
        {
            var currentValue = _symbolTable.GetValue(
                stmt.Identifier.Text,
                stmt.Identifier.Line, stmt.Identifier.Column, _errors);

            var addValue = EvaluateExpression(stmt.Expression);

            if (currentValue == null || addValue == null)
                return;

            object result = stmt.Operator.Type switch
            {
                TokenType.PlusEqual => EvaluateArithmeticOperation(currentValue,
                    new Token(TokenType.Plus, "+", null, stmt.Operator.Line, stmt.Operator.Column, 0),
                    addValue),
                TokenType.MinusEqual => EvaluateArithmeticOperation(currentValue,
                    new Token(TokenType.Minus, "-", null, stmt.Operator.Line, stmt.Operator.Column, 0),
                    addValue),
                TokenType.StarEqual => EvaluateArithmeticOperation(currentValue,
                    new Token(TokenType.Star, "*", null, stmt.Operator.Line, stmt.Operator.Column, 0),
                    addValue),
                TokenType.SlashEqual => EvaluateArithmeticOperation(currentValue,
                    new Token(TokenType.Slash, "/", null, stmt.Operator.Line, stmt.Operator.Column, 0),
                    addValue),
                TokenType.PercentEqual => EvaluateModulo(currentValue, addValue, stmt.Operator),
                _ => null
            };

            if (result != null)
            {
                _symbolTable.SetValue(
                    stmt.Identifier.Text, result,
                    stmt.Identifier.Line, stmt.Identifier.Column, _errors);
            }
        }

        /// <summary>
        /// Executes a standalone expression and displays the result.
        /// </summary>
        private void ExecuteStandaloneExpression(ExpressionStatement expr)
        {
            var result = EvaluateExpression(expr.Expression);

            // Only show result if it's not an increment expression (side effect only)
            if (result != null && !(expr.Expression is IncrementExpression))
            {
                string output = $"Result: {FormatValue(result)}";
                _output.Add(output);
                Console.WriteLine(output);
            }
        }

        /// <summary>
        /// Executes a print statement (Grigoraș 6.5).
        /// </summary>
        private void ExecutePrint(PrintStatement print)
        {
            var result = EvaluateExpression(print.Expression);

            if (result != null)
            {
                string output = FormatOutputValue(result);
                _output.Add(output);
                Console.WriteLine(output);
            }
        }

        /// <summary>
        /// Executes a return statement.
        /// </summary>
        private void ExecuteReturn(ReturnStatement ret)
        {
            object value = null;
            if (ret.Expression != null)
            {
                value = EvaluateExpression(ret.Expression);
            }
            throw new ReturnException(value);
        }

        /// <summary>
        /// Executes a FOR statement.
        /// </summary>
        private void ExecuteFor(ForStatement forStmt)
        {
            // Initialization
            if (forStmt.Initialization != null)
            {
                ExecuteStatement(forStmt.Initialization);
            }

            int iterations = 0;
            bool wasInLoop = _inLoop;
            _inLoop = true;

            try
            {
                // Loop
                while (true)
                {
                    if (++iterations > ITERATION_LIMIT)
                    {
                        _errors.Add(CompilationError.Semantic(
                            forStmt.ForKeyword.Line,
                            forStmt.ForKeyword.Column,
                            $"for loop exceeded limit of {ITERATION_LIMIT} iterations"));
                        break;
                    }

                    // Evaluate condition
                    if (forStmt.Condition != null)
                    {
                        var condition = EvaluateExpression(forStmt.Condition);

                        if (!IsTrue(condition))
                            break;
                    }

                    try
                    {
                        // Execute body
                        ExecuteStatement(forStmt.Body);
                    }
                    catch (ContinueException)
                    {
                        // Continue to increment
                    }
                    catch (BreakException)
                    {
                        break;
                    }

                    // Increment
                    if (forStmt.Increment != null)
                    {
                        ExecuteStatement(forStmt.Increment);
                    }
                }
            }
            finally
            {
                _inLoop = wasInLoop;
            }
        }

        /// <summary>
        /// Executes a WHILE statement.
        /// </summary>
        private void ExecuteWhile(WhileStatement whileStmt)
        {
            int iterations = 0;
            bool wasInLoop = _inLoop;
            _inLoop = true;

            try
            {
                while (true)
                {
                    if (++iterations > ITERATION_LIMIT)
                    {
                        _errors.Add(CompilationError.Semantic(
                            whileStmt.WhileKeyword.Line,
                            whileStmt.WhileKeyword.Column,
                            $"while loop exceeded limit of {ITERATION_LIMIT} iterations"));
                        break;
                    }

                    var condition = EvaluateExpression(whileStmt.Condition);

                    if (!IsTrue(condition))
                        break;

                    try
                    {
                        ExecuteStatement(whileStmt.Body);
                    }
                    catch (ContinueException)
                    {
                        // Continue to next iteration
                    }
                    catch (BreakException)
                    {
                        break;
                    }
                }
            }
            finally
            {
                _inLoop = wasInLoop;
            }
        }

        /// <summary>
        /// Executes an IF statement.
        /// </summary>
        private void ExecuteIf(IfStatement ifStmt)
        {
            var condition = EvaluateExpression(ifStmt.Condition);

            if (IsTrue(condition))
            {
                ExecuteStatement(ifStmt.ThenBody);
            }
            else if (ifStmt.ElseBody != null)
            {
                ExecuteStatement(ifStmt.ElseBody);
            }
        }

        /// <summary>
        /// Executes a block of statements.
        /// </summary>
        private void ExecuteBlock(BlockStatement block)
        {
            foreach (var stmt in block.Statements)
            {
                ExecuteStatement(stmt);
            }
        }

        #endregion

        #region Expression Evaluation

        /// <summary>
        /// Evaluates an expression and returns the result.
        /// </summary>
        public object EvaluateExpression(Expression expression)
        {
            return expression switch
            {
                NumericExpression num => EvaluateNumericExpression(num),
                StringExpression str => EvaluateStringExpression(str),
                BooleanExpression boolExpr => boolExpr.Value,
                IdentifierExpression id => EvaluateIdentifierExpression(id),
                UnaryExpression unary => EvaluateUnaryExpression(unary),
                NotExpression not => EvaluateNotExpression(not),
                BinaryExpression binary => EvaluateBinaryExpression(binary),
                LogicalExpression logical => EvaluateLogicalExpression(logical),
                ParenthesizedExpression paren => EvaluateExpression(paren.Expression),
                IncrementExpression inc => EvaluateIncrementExpression(inc),
                FunctionCallExpression call => EvaluateFunctionCall(call),
                ArrayAccessExpression arr => EvaluateArrayAccess(arr),
                _ => null
            };
        }

        private object EvaluateNumericExpression(NumericExpression num)
        {
            return num.Number.Value;
        }

        private object EvaluateStringExpression(StringExpression str)
        {
            return str.StringValue.Value;
        }

        private object EvaluateIdentifierExpression(IdentifierExpression id)
        {
            return _symbolTable.GetValue(
                id.Identifier.Text,
                id.Identifier.Line,
                id.Identifier.Column,
                _errors);
        }

        private object EvaluateUnaryExpression(UnaryExpression unary)
        {
            var operand = EvaluateExpression(unary.Operand);

            if (operand == null)
                return null;

            // Only unary minus
            if (unary.Operator.Type == TokenType.Minus)
            {
                if (operand is int i)
                    return -i;

                if (operand is double d)
                    return -d;

                _errors.Add(CompilationError.Semantic(
                    unary.Operator.Line, unary.Operator.Column,
                    $"unary minus operator cannot be applied to type {operand.GetType().Name}"));
            }

            return null;
        }

        private object EvaluateNotExpression(NotExpression not)
        {
            var operand = EvaluateExpression(not.Operand);

            if (operand == null)
                return null;

            return !IsTrue(operand);
        }

        private object EvaluateBinaryExpression(BinaryExpression binary)
        {
            var left = EvaluateExpression(binary.Left);
            var right = EvaluateExpression(binary.Right);

            if (left == null || right == null)
                return null;

            var op = binary.Operator;

            // Arithmetic operations
            if (op.IsArithmeticOperator())
            {
                if (op.Type == TokenType.Percent)
                {
                    return EvaluateModulo(left, right, op);
                }
                return EvaluateArithmeticOperation(left, op, right);
            }

            // Relational operations
            if (op.IsRelationalOperator())
            {
                return EvaluateRelationalOperation(left, op, right);
            }

            _errors.Add(CompilationError.Semantic(
                op.Line, op.Column,
                $"unknown operator '{op.Text}'"));

            return null;
        }

        /// <summary>
        /// Evaluates a logical expression with short-circuit evaluation.
        /// </summary>
        private object EvaluateLogicalExpression(LogicalExpression logical)
        {
            var left = EvaluateExpression(logical.Left);

            if (left == null)
                return null;

            bool leftBool = IsTrue(left);

            // Short-circuit evaluation
            if (logical.Operator.Type == TokenType.LogicalAnd)
            {
                // For &&: if left is false, return false without evaluating right
                if (!leftBool)
                    return false;

                var right = EvaluateExpression(logical.Right);
                return right != null && IsTrue(right);
            }
            else if (logical.Operator.Type == TokenType.LogicalOr)
            {
                // For ||: if left is true, return true without evaluating right
                if (leftBool)
                    return true;

                var right = EvaluateExpression(logical.Right);
                return right != null && IsTrue(right);
            }

            return null;
        }

        /// <summary>
        /// Evaluates an increment/decrement expression.
        /// </summary>
        private object EvaluateIncrementExpression(IncrementExpression inc)
        {
            var currentValue = _symbolTable.GetValue(
                inc.Identifier.Text,
                inc.Identifier.Line,
                inc.Identifier.Column,
                _errors);

            if (currentValue == null)
                return null;

            object newValue;
            object returnValue;

            if (currentValue is int intVal)
            {
                newValue = inc.IsIncrement ? intVal + 1 : intVal - 1;
                returnValue = inc.IsPrefix ? newValue : intVal;
            }
            else if (currentValue is double doubleVal)
            {
                newValue = inc.IsIncrement ? doubleVal + 1.0 : doubleVal - 1.0;
                returnValue = inc.IsPrefix ? newValue : doubleVal;
            }
            else
            {
                _errors.Add(CompilationError.Semantic(
                    inc.Operator.Line, inc.Operator.Column,
                    $"increment/decrement can only be applied to numeric types"));
                return null;
            }

            // Update the variable
            _symbolTable.SetValue(
                inc.Identifier.Text, newValue,
                inc.Identifier.Line, inc.Identifier.Column, _errors);

            return returnValue;
        }

        /// <summary>
        /// Evaluates a function call.
        /// </summary>
        private object EvaluateFunctionCall(FunctionCallExpression call)
        {
            string funcName = call.FunctionName.Text;

            // Check for built-in functions
            if (IsBuiltInFunction(funcName))
            {
                return EvaluateBuiltInFunction(funcName, call);
            }

            // User-defined function
            if (_functions.TryGetValue(funcName, out var funcDecl))
            {
                return ExecuteUserFunction(funcDecl, call);
            }

            _errors.Add(CompilationError.Semantic(
                call.FunctionName.Line, call.FunctionName.Column,
                $"undefined function '{funcName}'"));

            return null;
        }

        /// <summary>
        /// Checks if a function is built-in.
        /// </summary>
        private bool IsBuiltInFunction(string name)
        {
            return name == "print" || name == "sqrt" || name == "abs" ||
                   name == "exp" || name == "log" || name == "sin" ||
                   name == "cos" || name == "tan" || name == "pow" ||
                   name == "min" || name == "max" || name == "floor" ||
                   name == "ceil" || name == "round" || name == "length" ||
                   name == "input" || name == "parseInt" || name == "parseDouble" ||
                   name == "toString";
        }

        /// <summary>
        /// Evaluates a built-in function (Flex & Bison style).
        /// </summary>
        private object EvaluateBuiltInFunction(string funcName, FunctionCallExpression call)
        {
            var args = new List<object>();
            foreach (var arg in call.Arguments)
            {
                var value = EvaluateExpression(arg);
                if (value != null)
                    args.Add(value);
            }

            try
            {
                return funcName switch
                {
                    "print" => ExecutePrintFunction(args),
                    "sqrt" => Math.Sqrt(ConvertToDouble(args[0])),
                    "abs" => args[0] is int i ? Math.Abs(i) : Math.Abs(ConvertToDouble(args[0])),
                    "exp" => Math.Exp(ConvertToDouble(args[0])),
                    "log" => Math.Log(ConvertToDouble(args[0])),
                    "sin" => Math.Sin(ConvertToDouble(args[0])),
                    "cos" => Math.Cos(ConvertToDouble(args[0])),
                    "tan" => Math.Tan(ConvertToDouble(args[0])),
                    "pow" => Math.Pow(ConvertToDouble(args[0]), ConvertToDouble(args[1])),
                    "min" => Math.Min(ConvertToDouble(args[0]), ConvertToDouble(args[1])),
                    "max" => Math.Max(ConvertToDouble(args[0]), ConvertToDouble(args[1])),
                    "floor" => Math.Floor(ConvertToDouble(args[0])),
                    "ceil" => Math.Ceiling(ConvertToDouble(args[0])),
                    "round" => Math.Round(ConvertToDouble(args[0])),
                    "length" => args[0] is string s ? s.Length : 0,
                    "input" => Console.ReadLine() ?? "",
                    "parseInt" => int.TryParse(args[0]?.ToString(), out int pi) ? pi : 0,
                    "parseDouble" => double.TryParse(args[0]?.ToString(), out double pd) ? pd : 0.0,
                    "toString" => args[0]?.ToString() ?? "",
                    _ => null
                };
            }
            catch (Exception ex)
            {
                _errors.Add(CompilationError.Semantic(
                    call.FunctionName.Line, call.FunctionName.Column,
                    $"error calling function '{funcName}': {ex.Message}"));
                return null;
            }
        }

        /// <summary>
        /// Executes the print built-in function.
        /// </summary>
        private object ExecutePrintFunction(List<object> args)
        {
            if (args.Count > 0)
            {
                string output = FormatOutputValue(args[0]);
                _output.Add(output);
                Console.WriteLine(output);
            }
            return null;
        }

        /// <summary>
        /// Executes a user-defined function.
        /// </summary>
        private object ExecuteUserFunction(FunctionDeclaration func, FunctionCallExpression call)
        {
            // Check argument count
            if (call.Arguments.Count != func.Parameters.Count)
            {
                _errors.Add(CompilationError.Semantic(
                    call.FunctionName.Line, call.FunctionName.Column,
                    $"function '{func.Name.Text}' expects {func.Parameters.Count} arguments, got {call.Arguments.Count}"));
                return null;
            }

            // Save old values of parameters (in case they shadow global variables)
            var oldValues = new Dictionary<string, (object value, bool existed)>();

            // Evaluate arguments and bind to parameters
            for (int i = 0; i < func.Parameters.Count; i++)
            {
                var param = func.Parameters[i];
                var argValue = EvaluateExpression(call.Arguments[i]);

                // Save old value if variable exists
                int paramLine = param.Identifier.Line;
                int paramCol = param.Identifier.Column;

                if (_symbolTable.Exists(param.Identifier.Text))
                {
                    oldValues[param.Identifier.Text] = (
                        _symbolTable.GetValue(param.Identifier.Text, paramLine, paramCol, new List<CompilationError>()),
                        true
                    );
                }
                else
                {
                    oldValues[param.Identifier.Text] = (null, false);
                    var dataType = SymbolTable.ConvertToDataType(param.TypeKeyword.Type);
                    _symbolTable.Add(param.Identifier.Text, dataType, paramLine, paramCol, new List<CompilationError>());
                }

                // Set parameter value
                _symbolTable.SetValue(param.Identifier.Text, argValue, paramLine, paramCol, new List<CompilationError>());
            }

            try
            {
                // Execute function body
                ExecuteBlock(func.Body);
                return null; // No explicit return
            }
            catch (ReturnException ret)
            {
                return ret.Value;
            }
            finally
            {
                // Restore old values
                foreach (var kvp in oldValues)
                {
                    if (kvp.Value.existed)
                    {
                        _symbolTable.SetValue(kvp.Key, kvp.Value.value, 1, 1, new List<CompilationError>());
                    }
                }
            }
        }

        /// <summary>
        /// Evaluates an array access expression.
        /// </summary>
        private object EvaluateArrayAccess(ArrayAccessExpression arr)
        {
            // For now, just return null - array support would require more implementation
            _errors.Add(CompilationError.Semantic(
                arr.OpenBracket.Line, arr.OpenBracket.Column,
                "array access is not fully implemented yet"));
            return null;
        }

        #endregion

        #region Arithmetic Operations

        private object EvaluateArithmeticOperation(object left, Token op, object right)
        {
            // STRING + STRING (concatenation)
            if (left is string str1 && right is string str2)
            {
                if (op.Type == TokenType.Plus)
                {
                    return str1 + str2;
                }

                _errors.Add(CompilationError.Semantic(
                    op.Line, op.Column,
                    $"operation '{op.Text}' is not supported for strings (only + for concatenation)"));
                return null;
            }

            // STRING with NUMBER - ERROR
            if (left is string || right is string)
            {
                _errors.Add(CompilationError.Semantic(
                    op.Line, op.Column,
                    "type mismatch: cannot combine string with number"));
                return null;
            }

            // INT op INT -> INT
            if (left is int i1 && right is int i2)
            {
                return op.Type switch
                {
                    TokenType.Plus => CheckedAdd(i1, i2, op),
                    TokenType.Minus => CheckedSubtract(i1, i2, op),
                    TokenType.Star => CheckedMultiply(i1, i2, op),
                    TokenType.Slash => DivideInt(i1, i2, op),
                    _ => null
                };
            }

            // DOUBLE op DOUBLE -> DOUBLE
            if (left is double d1 && right is double d2)
            {
                return op.Type switch
                {
                    TokenType.Plus => d1 + d2,
                    TokenType.Minus => d1 - d2,
                    TokenType.Star => d1 * d2,
                    TokenType.Slash => DivideDouble(d1, d2, op),
                    _ => null
                };
            }

            // INT op DOUBLE -> DOUBLE (implicit conversion)
            if (left is int ii && right is double dd)
            {
                return EvaluateArithmeticOperation((double)ii, op, dd);
            }

            if (left is double di && right is int iii)
            {
                return EvaluateArithmeticOperation(di, op, (double)iii);
            }

            _errors.Add(CompilationError.Semantic(
                op.Line, op.Column,
                $"type mismatch: {left?.GetType().Name ?? "null"} {op.Text} {right?.GetType().Name ?? "null"}"));

            return null;
        }

        private object EvaluateModulo(object left, object right, Token op)
        {
            if (left is int i1 && right is int i2)
            {
                if (i2 == 0)
                {
                    _errors.Add(CompilationError.Semantic(op.Line, op.Column, "modulo by zero"));
                    return null;
                }
                return i1 % i2;
            }

            if (IsNumber(left) && IsNumber(right))
            {
                double d1 = ConvertToDouble(left);
                double d2 = ConvertToDouble(right);
                if (Math.Abs(d2) < EPSILON)
                {
                    _errors.Add(CompilationError.Semantic(op.Line, op.Column, "modulo by zero"));
                    return null;
                }
                return d1 % d2;
            }

            _errors.Add(CompilationError.Semantic(
                op.Line, op.Column,
                "modulo operator requires numeric operands"));
            return null;
        }

        private object CheckedAdd(int a, int b, Token op)
        {
            try
            {
                return checked(a + b);
            }
            catch (OverflowException)
            {
                _errors.Add(CompilationError.Semantic(op.Line, op.Column, "integer addition overflow"));
                return null;
            }
        }

        private object CheckedSubtract(int a, int b, Token op)
        {
            try
            {
                return checked(a - b);
            }
            catch (OverflowException)
            {
                _errors.Add(CompilationError.Semantic(op.Line, op.Column, "integer subtraction overflow"));
                return null;
            }
        }

        private object CheckedMultiply(int a, int b, Token op)
        {
            try
            {
                return checked(a * b);
            }
            catch (OverflowException)
            {
                _errors.Add(CompilationError.Semantic(op.Line, op.Column, "integer multiplication overflow"));
                return null;
            }
        }

        private object DivideInt(int a, int b, Token op)
        {
            if (b == 0)
            {
                _errors.Add(CompilationError.Semantic(op.Line, op.Column, "division by zero"));
                return null;
            }
            return a / b;
        }

        private object DivideDouble(double a, double b, Token op)
        {
            if (Math.Abs(b) < EPSILON)
            {
                _errors.Add(CompilationError.Semantic(op.Line, op.Column, "division by zero"));
                return null;
            }
            return a / b;
        }

        #endregion

        #region Relational Operations

        private object EvaluateRelationalOperation(object left, Token op, object right)
        {
            // Comparisons only between numbers
            if (!IsNumber(left) || !IsNumber(right))
            {
                _errors.Add(CompilationError.Semantic(
                    op.Line, op.Column,
                    "relational operators can only be applied to numbers"));
                return null;
            }

            double val1 = ConvertToDouble(left);
            double val2 = ConvertToDouble(right);

            return op.Type switch
            {
                TokenType.LessThan => val1 < val2,
                TokenType.GreaterThan => val1 > val2,
                TokenType.LessThanOrEqual => val1 <= val2,
                TokenType.GreaterThanOrEqual => val1 >= val2,
                TokenType.EqualEqual => Math.Abs(val1 - val2) < EPSILON,
                TokenType.NotEqual => Math.Abs(val1 - val2) >= EPSILON,
                _ => null
            };
        }

        #endregion

        #region Helper Methods

        private bool IsNumber(object value)
        {
            return value is int || value is double;
        }

        private double ConvertToDouble(object value)
        {
            return value switch
            {
                int i => i,
                double d => d,
                _ => 0
            };
        }

        private bool IsTrue(object value)
        {
            if (value is bool b)
                return b;

            // For numbers: 0 = false, anything else = true
            if (value is int i)
                return i != 0;

            if (value is double d)
                return Math.Abs(d) >= EPSILON;

            // Non-null string is true
            if (value is string s)
                return !string.IsNullOrEmpty(s);

            return false;
        }

        private object ConvertToType(object value, DataType type, int line, int column)
        {
            if (value == null)
                return null;

            return type switch
            {
                DataType.Int when value is int => value,
                DataType.Int when value is double d => (int)d,
                DataType.Int when value is bool b => b ? 1 : 0,
                DataType.Double when value is double => value,
                DataType.Double when value is int i => (double)i,
                DataType.Double when value is bool b => b ? 1.0 : 0.0,
                DataType.String when value is string => value,
                DataType.String => value.ToString(),
                DataType.Bool when value is bool => value,
                DataType.Bool when IsNumber(value) => IsTrue(value),
                _ => ReturnConversionError(value, type, line, column)
            };
        }

        private object ReturnConversionError(object value, DataType type, int line, int column)
        {
            _errors.Add(CompilationError.Semantic(
                line, column,
                $"cannot convert {value?.GetType().Name ?? "null"} to {type}"));
            return null;
        }

        private string FormatValue(object value)
        {
            if (value is string str)
                return $"\"{str}\"";

            if (value is bool b)
                return b ? "true" : "false";

            return value?.ToString() ?? "null";
        }

        private string FormatOutputValue(object value)
        {
            if (value is string str)
                return str;  // Don't add quotes for print

            if (value is bool b)
                return b ? "true" : "false";

            if (value is double d)
                return d.ToString(System.Globalization.CultureInfo.InvariantCulture);

            return value?.ToString() ?? "null";
        }

        #endregion
    }
}
