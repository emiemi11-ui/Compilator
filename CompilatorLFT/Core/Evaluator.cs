using System;
using System.Collections.Generic;
using CompilatorLFT.Models;
using CompilatorLFT.Models.Expressions;
using CompilatorLFT.Models.Statements;
using CompilatorLFT.Utils;

namespace CompilatorLFT.Core
{
    /// <summary>
    /// Evaluator for expressions and executor for statements.
    /// </summary>
    /// <remarks>
    /// Reference: Dragon Book, Ch. 5 - Syntax-Directed Translation
    /// Implements Visitor Pattern for AST traversal.
    /// </remarks>
    public class Evaluator
    {
        #region Private Fields

        private readonly SymbolTable _symbolTable;
        private readonly List<CompilationError> _errors;
        private readonly List<string> _output;

        // Constant for floating point comparison
        private const double EPSILON = 1e-10;

        // Limit for loops (to avoid infinite loops)
        private const int ITERATION_LIMIT = 100000;

        #endregion

        #region Properties

        /// <summary>List of evaluation errors.</summary>
        public IReadOnlyList<CompilationError> Errors => _errors;

        /// <summary>Output generated by evaluation.</summary>
        public IReadOnlyList<string> Output => _output;

        #endregion

        #region Constructor

        /// <summary>
        /// Initializes the evaluator with the symbol table.
        /// </summary>
        /// <param name="symbolTable">Symbol table populated by parser</param>
        public Evaluator(SymbolTable symbolTable)
        {
            _symbolTable = symbolTable ?? throw new ArgumentNullException(nameof(symbolTable));
            _errors = new List<CompilationError>();
            _output = new List<string>();
        }

        #endregion

        #region Program Execution

        /// <summary>
        /// Executes the entire program.
        /// </summary>
        /// <param name="program">Program to execute</param>
        public void ExecuteProgram(Program program)
        {
            foreach (var statement in program.Statements)
            {
                ExecuteStatement(statement);
            }
        }

        /// <summary>
        /// Executes a statement.
        /// </summary>
        private void ExecuteStatement(Statement statement)
        {
            switch (statement)
            {
                case DeclarationStatement decl:
                    ExecuteDeclaration(decl);
                    break;

                case AssignmentStatement assign:
                    ExecuteAssignment(assign);
                    break;

                case ExpressionStatement expr:
                    ExecuteStandaloneExpression(expr);
                    break;

                case ForStatement forStmt:
                    ExecuteFor(forStmt);
                    break;

                case WhileStatement whileStmt:
                    ExecuteWhile(whileStmt);
                    break;

                case IfStatement ifStmt:
                    ExecuteIf(ifStmt);
                    break;

                case BlockStatement block:
                    ExecuteBlock(block);
                    break;
            }
        }

        /// <summary>
        /// Executes a variable declaration.
        /// </summary>
        private void ExecuteDeclaration(DeclarationStatement decl)
        {
            var dataType = SymbolTable.ConvertToDataType(decl.TypeKeyword.Type);

            foreach (var (id, initExpr) in decl.Declarations)
            {
                if (initExpr != null)
                {
                    var value = EvaluateExpression(initExpr);

                    if (value != null)
                    {
                        var convertedValue = ConvertToType(value, dataType, id.Line, id.Column);

                        if (convertedValue != null)
                        {
                            _symbolTable.SetValue(
                                id.Text, convertedValue,
                                id.Line, id.Column, _errors);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Executes an assignment.
        /// </summary>
        private void ExecuteAssignment(AssignmentStatement assign)
        {
            var value = EvaluateExpression(assign.Expression);

            if (value != null)
            {
                var variable = _symbolTable.Get(assign.Identifier.Text);

                if (variable != null)
                {
                    var convertedValue = ConvertToType(
                        value, variable.Type,
                        assign.Identifier.Line, assign.Identifier.Column);

                    if (convertedValue != null)
                    {
                        _symbolTable.SetValue(
                            assign.Identifier.Text, convertedValue,
                            assign.Identifier.Line, assign.Identifier.Column,
                            _errors);
                    }
                }
            }
        }

        /// <summary>
        /// Executes a standalone expression and displays the result.
        /// </summary>
        private void ExecuteStandaloneExpression(ExpressionStatement expr)
        {
            var result = EvaluateExpression(expr.Expression);

            if (result != null)
            {
                string output = $"Result: {FormatValue(result)}";
                _output.Add(output);
                Console.WriteLine(output);
            }
        }

        /// <summary>
        /// Executes a FOR statement.
        /// </summary>
        private void ExecuteFor(ForStatement forStmt)
        {
            // Initialization
            if (forStmt.Initialization != null)
            {
                ExecuteStatement(forStmt.Initialization);
            }

            int iterations = 0;

            // Loop
            while (true)
            {
                if (++iterations > ITERATION_LIMIT)
                {
                    _errors.Add(CompilationError.Semantic(
                        forStmt.ForKeyword.Line,
                        forStmt.ForKeyword.Column,
                        $"for loop exceeded limit of {ITERATION_LIMIT} iterations"));
                    break;
                }

                // Evaluate condition
                if (forStmt.Condition != null)
                {
                    var condition = EvaluateExpression(forStmt.Condition);

                    if (!IsTrue(condition))
                        break;
                }

                // Execute body
                ExecuteStatement(forStmt.Body);

                // Increment
                if (forStmt.Increment != null)
                {
                    ExecuteStatement(forStmt.Increment);
                }
            }
        }

        /// <summary>
        /// Executes a WHILE statement.
        /// </summary>
        private void ExecuteWhile(WhileStatement whileStmt)
        {
            int iterations = 0;

            while (true)
            {
                if (++iterations > ITERATION_LIMIT)
                {
                    _errors.Add(CompilationError.Semantic(
                        whileStmt.WhileKeyword.Line,
                        whileStmt.WhileKeyword.Column,
                        $"while loop exceeded limit of {ITERATION_LIMIT} iterations"));
                    break;
                }

                var condition = EvaluateExpression(whileStmt.Condition);

                if (!IsTrue(condition))
                    break;

                ExecuteStatement(whileStmt.Body);
            }
        }

        /// <summary>
        /// Executes an IF statement.
        /// </summary>
        private void ExecuteIf(IfStatement ifStmt)
        {
            var condition = EvaluateExpression(ifStmt.Condition);

            if (IsTrue(condition))
            {
                ExecuteStatement(ifStmt.ThenBody);
            }
            else if (ifStmt.ElseBody != null)
            {
                ExecuteStatement(ifStmt.ElseBody);
            }
        }

        /// <summary>
        /// Executes a block of statements.
        /// </summary>
        private void ExecuteBlock(BlockStatement block)
        {
            foreach (var stmt in block.Statements)
            {
                ExecuteStatement(stmt);
            }
        }

        #endregion

        #region Expression Evaluation

        /// <summary>
        /// Evaluates an expression and returns the result.
        /// </summary>
        public object EvaluateExpression(Expression expression)
        {
            return expression switch
            {
                NumericExpression num => EvaluateNumericExpression(num),
                StringExpression str => EvaluateStringExpression(str),
                IdentifierExpression id => EvaluateIdentifierExpression(id),
                UnaryExpression unary => EvaluateUnaryExpression(unary),
                BinaryExpression binary => EvaluateBinaryExpression(binary),
                ParenthesizedExpression paren => EvaluateExpression(paren.Expression),
                _ => null
            };
        }

        private object EvaluateNumericExpression(NumericExpression num)
        {
            return num.Number.Value;
        }

        private object EvaluateStringExpression(StringExpression str)
        {
            return str.StringValue.Value;
        }

        private object EvaluateIdentifierExpression(IdentifierExpression id)
        {
            return _symbolTable.GetValue(
                id.Identifier.Text,
                id.Identifier.Line,
                id.Identifier.Column,
                _errors);
        }

        private object EvaluateUnaryExpression(UnaryExpression unary)
        {
            var operand = EvaluateExpression(unary.Operand);

            if (operand == null)
                return null;

            // Only unary minus
            if (unary.Operator.Type == TokenType.Minus)
            {
                if (operand is int i)
                    return -i;

                if (operand is double d)
                    return -d;

                _errors.Add(CompilationError.Semantic(
                    unary.Operator.Line, unary.Operator.Column,
                    $"unary minus operator cannot be applied to type {operand.GetType().Name}"));
            }

            return null;
        }

        private object EvaluateBinaryExpression(BinaryExpression binary)
        {
            var left = EvaluateExpression(binary.Left);
            var right = EvaluateExpression(binary.Right);

            if (left == null || right == null)
                return null;

            var op = binary.Operator;

            // Arithmetic operations
            if (op.IsArithmeticOperator())
            {
                return EvaluateArithmeticOperation(left, op, right);
            }

            // Relational operations
            if (op.IsRelationalOperator())
            {
                return EvaluateRelationalOperation(left, op, right);
            }

            _errors.Add(CompilationError.Semantic(
                op.Line, op.Column,
                $"unknown operator '{op.Text}'"));

            return null;
        }

        #endregion

        #region Arithmetic Operations

        private object EvaluateArithmeticOperation(object left, Token op, object right)
        {
            // STRING + STRING (concatenation)
            if (left is string str1 && right is string str2)
            {
                if (op.Type == TokenType.Plus)
                {
                    return str1 + str2;
                }

                _errors.Add(CompilationError.Semantic(
                    op.Line, op.Column,
                    $"operation '{op.Text}' is not supported for strings (only + for concatenation)"));
                return null;
            }

            // STRING with NUMBER - ERROR
            if (left is string || right is string)
            {
                _errors.Add(CompilationError.Semantic(
                    op.Line, op.Column,
                    "type mismatch: cannot combine string with number"));
                return null;
            }

            // INT op INT -> INT
            if (left is int i1 && right is int i2)
            {
                return op.Type switch
                {
                    TokenType.Plus => CheckedAdd(i1, i2, op),
                    TokenType.Minus => CheckedSubtract(i1, i2, op),
                    TokenType.Star => CheckedMultiply(i1, i2, op),
                    TokenType.Slash => DivideInt(i1, i2, op),
                    _ => null
                };
            }

            // DOUBLE op DOUBLE -> DOUBLE
            if (left is double d1 && right is double d2)
            {
                return op.Type switch
                {
                    TokenType.Plus => d1 + d2,
                    TokenType.Minus => d1 - d2,
                    TokenType.Star => d1 * d2,
                    TokenType.Slash => DivideDouble(d1, d2, op),
                    _ => null
                };
            }

            // INT op DOUBLE -> DOUBLE (implicit conversion)
            if (left is int ii && right is double dd)
            {
                return EvaluateArithmeticOperation((double)ii, op, dd);
            }

            if (left is double di && right is int iii)
            {
                return EvaluateArithmeticOperation(di, op, (double)iii);
            }

            _errors.Add(CompilationError.Semantic(
                op.Line, op.Column,
                $"type mismatch: {left?.GetType().Name ?? "null"} {op.Text} {right?.GetType().Name ?? "null"}"));

            return null;
        }

        private object CheckedAdd(int a, int b, Token op)
        {
            try
            {
                return checked(a + b);
            }
            catch (OverflowException)
            {
                _errors.Add(CompilationError.Semantic(op.Line, op.Column, "integer addition overflow"));
                return null;
            }
        }

        private object CheckedSubtract(int a, int b, Token op)
        {
            try
            {
                return checked(a - b);
            }
            catch (OverflowException)
            {
                _errors.Add(CompilationError.Semantic(op.Line, op.Column, "integer subtraction overflow"));
                return null;
            }
        }

        private object CheckedMultiply(int a, int b, Token op)
        {
            try
            {
                return checked(a * b);
            }
            catch (OverflowException)
            {
                _errors.Add(CompilationError.Semantic(op.Line, op.Column, "integer multiplication overflow"));
                return null;
            }
        }

        private object DivideInt(int a, int b, Token op)
        {
            if (b == 0)
            {
                _errors.Add(CompilationError.Semantic(op.Line, op.Column, "division by zero"));
                return null;
            }
            return a / b;
        }

        private object DivideDouble(double a, double b, Token op)
        {
            if (Math.Abs(b) < EPSILON)
            {
                _errors.Add(CompilationError.Semantic(op.Line, op.Column, "division by zero"));
                return null;
            }
            return a / b;
        }

        #endregion

        #region Relational Operations

        private object EvaluateRelationalOperation(object left, Token op, object right)
        {
            // Comparisons only between numbers
            if (!IsNumber(left) || !IsNumber(right))
            {
                _errors.Add(CompilationError.Semantic(
                    op.Line, op.Column,
                    "relational operators can only be applied to numbers"));
                return null;
            }

            double val1 = ConvertToDouble(left);
            double val2 = ConvertToDouble(right);

            return op.Type switch
            {
                TokenType.LessThan => val1 < val2,
                TokenType.GreaterThan => val1 > val2,
                TokenType.LessThanOrEqual => val1 <= val2,
                TokenType.GreaterThanOrEqual => val1 >= val2,
                TokenType.EqualEqual => Math.Abs(val1 - val2) < EPSILON,
                TokenType.NotEqual => Math.Abs(val1 - val2) >= EPSILON,
                _ => null
            };
        }

        #endregion

        #region Helper Methods

        private bool IsNumber(object value)
        {
            return value is int || value is double;
        }

        private double ConvertToDouble(object value)
        {
            return value switch
            {
                int i => i,
                double d => d,
                _ => 0
            };
        }

        private bool IsTrue(object value)
        {
            if (value is bool b)
                return b;

            // For numbers: 0 = false, anything else = true
            if (value is int i)
                return i != 0;

            if (value is double d)
                return Math.Abs(d) >= EPSILON;

            return false;
        }

        private object ConvertToType(object value, DataType type, int line, int column)
        {
            if (value == null)
                return null;

            return type switch
            {
                DataType.Int when value is int => value,
                DataType.Int when value is double d => (int)d,
                DataType.Double when value is double => value,
                DataType.Double when value is int i => (double)i,
                DataType.String when value is string => value,
                _ => ReturnConversionError(value, type, line, column)
            };
        }

        private object ReturnConversionError(object value, DataType type, int line, int column)
        {
            _errors.Add(CompilationError.Semantic(
                line, column,
                $"cannot convert {value?.GetType().Name ?? "null"} to {type}"));
            return null;
        }

        private string FormatValue(object value)
        {
            if (value is string str)
                return $"\"{str}\"";

            if (value is bool b)
                return b ? "true" : "false";

            return value?.ToString() ?? "null";
        }

        #endregion
    }
}
