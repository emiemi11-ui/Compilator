using System;
using System.Collections.Generic;
using CompilatorLFT.Models;
using CompilatorLFT.Models.Expressions;
using CompilatorLFT.Models.Statements;
using CompilatorLFT.Utils;
using ProgramNode = CompilatorLFT.Models.Statements.Program;

namespace CompilatorLFT.Core
{
    /// <summary>
    /// Evaluator for expressions and executor for statements.
    /// Uses hierarchical scoping via ScopeManager for proper variable isolation.
    /// </summary>
    /// <remarks>
    /// Reference: Dragon Book, Ch. 5 - Syntax-Directed Translation
    /// Reference: Grigoraș "Proiectarea Compilatoarelor", Cap. 6.5
    /// Reference: Levine "Flex & Bison", Ch. 3
    ///
    /// Implements:
    /// - Tree-walking interpreter (Visitor Pattern for AST traversal)
    /// - Hierarchical scoping (ScopeManager with proper scope chains)
    /// - Function scoping (parameters and locals in function scope)
    /// - Block scoping (FOR/WHILE/IF with proper variable isolation)
    /// - Recursion support (separate scope for each function call)
    /// - Print statement (Grigoraș 6.5)
    /// - User-defined functions (Flex & Bison style)
    /// - Built-in functions (sqrt, abs, exp, log, etc.)
    /// - Logical operators with short-circuit evaluation (&&, ||, !)
    /// - Break/Continue statements
    /// - Return statements
    /// - Increment/decrement operators (++, --)
    /// - Compound assignment operators (+=, -=, *=, /=, %=)
    /// - Arrays (declaration, initialization, access)
    /// </remarks>
    public class Evaluator
    {
        #region Private Fields

        private readonly ScopeManager _scopeManager;
        private readonly List<CompilationError> _errors;
        private readonly List<string> _output;
        private readonly Dictionary<string, FunctionDeclaration> _functions;

        // Track recursion depth to prevent stack overflow
        private int _callDepth;
        private const int MAX_CALL_DEPTH = 1000;

        private bool _inLoop;

        // Constant for floating point comparison
        private const double EPSILON = 1e-10;

        // Limit for loops (to avoid infinite loops)
        private const int ITERATION_LIMIT = 100000;

        #endregion

        #region Control Flow Exceptions

        /// <summary>Exception for break statement.</summary>
        private class BreakException : Exception { }

        /// <summary>Exception for continue statement.</summary>
        private class ContinueException : Exception { }

        /// <summary>Exception for return statement.</summary>
        private class ReturnException : Exception
        {
            public object Value { get; }
            public ReturnException(object value) => Value = value;
        }

        #endregion

        #region Properties

        /// <summary>List of evaluation errors.</summary>
        public IReadOnlyList<CompilationError> Errors => _errors;

        /// <summary>Output generated by evaluation.</summary>
        public IReadOnlyList<string> Output => _output;

        /// <summary>The scope manager for debugging.</summary>
        public ScopeManager ScopeManager => _scopeManager;

        #endregion

        #region Constructor

        /// <summary>
        /// Initializes the evaluator with a scope manager.
        /// </summary>
        /// <param name="scopeManager">Optional scope manager (creates new if null)</param>
        /// <param name="functions">User-defined functions</param>
        public Evaluator(ScopeManager scopeManager = null, Dictionary<string, FunctionDeclaration> functions = null)
        {
            _scopeManager = scopeManager ?? new ScopeManager();
            _functions = functions ?? new Dictionary<string, FunctionDeclaration>();
            _errors = new List<CompilationError>();
            _output = new List<string>();
            _callDepth = 0;
            _inLoop = false;
        }

        /// <summary>
        /// Initializes the evaluator with a symbol table (backward compatibility).
        /// Creates a ScopeManager internally. Variables will be declared during execution.
        /// </summary>
        /// <param name="symbolTable">Symbol table populated by parser (used for backward compatibility, not for pre-populating)</param>
        /// <param name="functions">User-defined functions</param>
        public Evaluator(SymbolTable symbolTable, Dictionary<string, FunctionDeclaration> functions = null)
        {
            _scopeManager = new ScopeManager();
            _functions = functions ?? new Dictionary<string, FunctionDeclaration>();
            _errors = new List<CompilationError>();
            _output = new List<string>();
            _callDepth = 0;
            _inLoop = false;

            // NOTE: We do NOT copy variables from SymbolTable to ScopeManager here.
            // Variables will be declared during execution via ExecuteDeclaration.
            // This prevents "already declared in current scope" errors that occurred
            // when variables were declared both here and during execution.
        }

        #endregion

        #region Program Execution

        /// <summary>
        /// Executes the entire program.
        /// </summary>
        /// <param name="program">Program to execute</param>
        public void ExecuteProgram(ProgramNode program)
        {
            // Register user-defined functions
            foreach (var func in program.Functions)
            {
                _functions[func.Name.Text] = func;
            }

            // Execute all statements
            foreach (var statement in program.Statements)
            {
                try
                {
                    ExecuteStatement(statement);
                }
                catch (ReturnException)
                {
                    _errors.Add(CompilationError.Semantic(1, 1,
                        "return statement outside of function"));
                }
                catch (BreakException)
                {
                    _errors.Add(CompilationError.Semantic(1, 1,
                        "break statement outside of loop"));
                }
                catch (ContinueException)
                {
                    _errors.Add(CompilationError.Semantic(1, 1,
                        "continue statement outside of loop"));
                }
            }
        }

        /// <summary>
        /// Executes a statement.
        /// </summary>
        private void ExecuteStatement(Statement statement)
        {
            switch (statement)
            {
                case DeclarationStatement decl:
                    ExecuteDeclaration(decl);
                    break;

                case AssignmentStatement assign:
                    ExecuteAssignment(assign);
                    break;

                case CompoundAssignmentStatement compound:
                    ExecuteCompoundAssignment(compound);
                    break;

                case ExpressionStatement expr:
                    ExecuteStandaloneExpression(expr);
                    break;

                case PrintStatement print:
                    ExecutePrint(print);
                    break;

                case BreakStatement:
                    throw new BreakException();

                case ContinueStatement:
                    throw new ContinueException();

                case ReturnStatement ret:
                    ExecuteReturn(ret);
                    break;

                case ForStatement forStmt:
                    ExecuteFor(forStmt);
                    break;

                case WhileStatement whileStmt:
                    ExecuteWhile(whileStmt);
                    break;

                case IfStatement ifStmt:
                    ExecuteIf(ifStmt);
                    break;

                case BlockStatement block:
                    ExecuteBlock(block);
                    break;

                case ArrayAssignmentStatement arrAssign:
                    ExecuteArrayAssignment(arrAssign);
                    break;
            }
        }

        /// <summary>
        /// Executes an array element assignment (arr[i] = value).
        /// </summary>
        private void ExecuteArrayAssignment(ArrayAssignmentStatement stmt)
        {
            var value = EvaluateExpression(stmt.Expression);
            if (value == null) return;

            // Get the array and index
            var arrExpr = stmt.ArrayAccess;
            var arrayValue = EvaluateExpression(arrExpr.Array);
            var indexValue = EvaluateExpression(arrExpr.Index);

            if (arrayValue == null || indexValue == null) return;

            int index;
            if (indexValue is int i)
            {
                index = i;
            }
            else if (indexValue is double d)
            {
                index = (int)d;
            }
            else
            {
                _errors.Add(CompilationError.Semantic(
                    arrExpr.OpenBracket.Line, arrExpr.OpenBracket.Column,
                    "array index must be numeric"));
                return;
            }

            if (arrayValue is List<object> list)
            {
                if (index < 0 || index >= list.Count)
                {
                    _errors.Add(CompilationError.Semantic(
                        arrExpr.OpenBracket.Line, arrExpr.OpenBracket.Column,
                        $"array index {index} out of bounds (length: {list.Count})"));
                    return;
                }
                list[index] = value;
            }
            else
            {
                _errors.Add(CompilationError.Semantic(
                    arrExpr.OpenBracket.Line, arrExpr.OpenBracket.Column,
                    $"cannot assign to index of type {arrayValue.GetType().Name}"));
            }
        }

        /// <summary>
        /// Executes a variable declaration in the current scope.
        /// </summary>
        private void ExecuteDeclaration(DeclarationStatement decl)
        {
            var dataType = GetDataType(decl.TypeKeyword.Type);

            // Override for array types (e.g., int[] arr = [1, 2, 3])
            if (decl.IsArrayType)
            {
                dataType = DataType.Array;
            }

            foreach (var (id, initExpr) in decl.Declarations)
            {
                // Declare variable in current scope
                _scopeManager.DeclareVariable(id.Text, dataType, id.Line, id.Column, _errors);

                if (initExpr != null)
                {
                    var value = EvaluateExpression(initExpr);

                    if (value != null)
                    {
                        var convertedValue = ConvertToType(value, dataType, id.Line, id.Column);

                        if (convertedValue != null)
                        {
                            _scopeManager.SetVariableValue(
                                id.Text, convertedValue,
                                id.Line, id.Column, _errors);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Executes an assignment using scope chain lookup.
        /// </summary>
        private void ExecuteAssignment(AssignmentStatement assign)
        {
            var value = EvaluateExpression(assign.Expression);

            if (value != null)
            {
                var variable = _scopeManager.LookupVariable(
                    assign.Identifier.Text,
                    assign.Identifier.Line,
                    assign.Identifier.Column,
                    _errors);

                if (variable != null)
                {
                    var convertedValue = ConvertToType(
                        value, variable.Type,
                        assign.Identifier.Line, assign.Identifier.Column);

                    if (convertedValue != null)
                    {
                        _scopeManager.SetVariableValue(
                            assign.Identifier.Text, convertedValue,
                            assign.Identifier.Line, assign.Identifier.Column,
                            _errors);
                    }
                }
            }
        }

        /// <summary>
        /// Executes a compound assignment (+=, -=, *=, /=, %=).
        /// </summary>
        private void ExecuteCompoundAssignment(CompoundAssignmentStatement stmt)
        {
            var currentValue = _scopeManager.GetVariableValue(
                stmt.Identifier.Text,
                stmt.Identifier.Line, stmt.Identifier.Column, _errors);

            var addValue = EvaluateExpression(stmt.Expression);

            if (currentValue == null || addValue == null)
                return;

            object result = stmt.Operator.Type switch
            {
                TokenType.PlusEqual => EvaluateArithmeticOperation(currentValue,
                    new Token(TokenType.Plus, "+", null, stmt.Operator.Line, stmt.Operator.Column, 0),
                    addValue),
                TokenType.MinusEqual => EvaluateArithmeticOperation(currentValue,
                    new Token(TokenType.Minus, "-", null, stmt.Operator.Line, stmt.Operator.Column, 0),
                    addValue),
                TokenType.StarEqual => EvaluateArithmeticOperation(currentValue,
                    new Token(TokenType.Star, "*", null, stmt.Operator.Line, stmt.Operator.Column, 0),
                    addValue),
                TokenType.SlashEqual => EvaluateArithmeticOperation(currentValue,
                    new Token(TokenType.Slash, "/", null, stmt.Operator.Line, stmt.Operator.Column, 0),
                    addValue),
                TokenType.PercentEqual => EvaluateModulo(currentValue, addValue, stmt.Operator),
                _ => null
            };

            if (result != null)
            {
                _scopeManager.SetVariableValue(
                    stmt.Identifier.Text, result,
                    stmt.Identifier.Line, stmt.Identifier.Column, _errors);
            }
        }

        /// <summary>
        /// Executes a standalone expression and displays the result.
        /// </summary>
        private void ExecuteStandaloneExpression(ExpressionStatement expr)
        {
            var result = EvaluateExpression(expr.Expression);

            // Only show result if it's not an increment expression (side effect only)
            if (result != null && !(expr.Expression is IncrementExpression))
            {
                string output = $"Result: {FormatValue(result)}";
                _output.Add(output);
                Console.WriteLine(output);
            }
        }

        /// <summary>
        /// Executes a print statement (Grigoraș 6.5).
        /// </summary>
        private void ExecutePrint(PrintStatement print)
        {
            var result = EvaluateExpression(print.Expression);

            if (result != null)
            {
                string output = FormatOutputValue(result);
                _output.Add(output);
                Console.WriteLine(output);
            }
        }

        /// <summary>
        /// Executes a return statement.
        /// </summary>
        private void ExecuteReturn(ReturnStatement ret)
        {
            object value = null;
            if (ret.Expression != null)
            {
                value = EvaluateExpression(ret.Expression);
            }
            throw new ReturnException(value);
        }

        /// <summary>
        /// Executes a FOR statement with proper scoping.
        /// FOR loop variables are declared in their own scope.
        /// </summary>
        private void ExecuteFor(ForStatement forStmt)
        {
            // Push a new scope for the FOR loop (isolates loop variable)
            _scopeManager.PushScope($"for_L{forStmt.ForKeyword.Line}");

            try
            {
                // Initialization (variable declared in FOR scope)
                if (forStmt.Initialization != null)
                {
                    ExecuteStatement(forStmt.Initialization);
                }

                int iterations = 0;
                bool wasInLoop = _inLoop;
                _inLoop = true;

                try
                {
                    // Loop
                    while (true)
                    {
                        if (++iterations > ITERATION_LIMIT)
                        {
                            _errors.Add(CompilationError.Semantic(
                                forStmt.ForKeyword.Line,
                                forStmt.ForKeyword.Column,
                                $"for loop exceeded limit of {ITERATION_LIMIT} iterations"));
                            break;
                        }

                        // Evaluate condition
                        if (forStmt.Condition != null)
                        {
                            var condition = EvaluateExpression(forStmt.Condition);

                            if (!IsTrue(condition))
                                break;
                        }

                        try
                        {
                            // Execute body
                            ExecuteStatement(forStmt.Body);
                        }
                        catch (ContinueException)
                        {
                            // Continue to increment
                        }
                        catch (BreakException)
                        {
                            break;
                        }

                        // Increment
                        if (forStmt.Increment != null)
                        {
                            ExecuteStatement(forStmt.Increment);
                        }
                    }
                }
                finally
                {
                    _inLoop = wasInLoop;
                }
            }
            finally
            {
                // Pop the FOR loop scope
                _scopeManager.PopScope();
            }
        }

        /// <summary>
        /// Executes a WHILE statement.
        /// </summary>
        private void ExecuteWhile(WhileStatement whileStmt)
        {
            int iterations = 0;
            bool wasInLoop = _inLoop;
            _inLoop = true;

            try
            {
                while (true)
                {
                    if (++iterations > ITERATION_LIMIT)
                    {
                        _errors.Add(CompilationError.Semantic(
                            whileStmt.WhileKeyword.Line,
                            whileStmt.WhileKeyword.Column,
                            $"while loop exceeded limit of {ITERATION_LIMIT} iterations"));
                        break;
                    }

                    var condition = EvaluateExpression(whileStmt.Condition);

                    if (!IsTrue(condition))
                        break;

                    try
                    {
                        ExecuteStatement(whileStmt.Body);
                    }
                    catch (ContinueException)
                    {
                        // Continue to next iteration
                    }
                    catch (BreakException)
                    {
                        break;
                    }
                }
            }
            finally
            {
                _inLoop = wasInLoop;
            }
        }

        /// <summary>
        /// Executes an IF statement.
        /// </summary>
        private void ExecuteIf(IfStatement ifStmt)
        {
            var condition = EvaluateExpression(ifStmt.Condition);

            if (IsTrue(condition))
            {
                ExecuteStatement(ifStmt.ThenBody);
            }
            else if (ifStmt.ElseBody != null)
            {
                ExecuteStatement(ifStmt.ElseBody);
            }
        }

        /// <summary>
        /// Executes a block of statements with proper scoping.
        /// </summary>
        private void ExecuteBlock(BlockStatement block)
        {
            // Push a new block scope
            _scopeManager.PushBlockScope(block.OpenBrace.Line);

            try
            {
                foreach (var stmt in block.Statements)
                {
                    ExecuteStatement(stmt);
                }
            }
            finally
            {
                // Pop the block scope
                _scopeManager.PopScope();
            }
        }

        #endregion

        #region Expression Evaluation

        /// <summary>
        /// Evaluates an expression and returns the result.
        /// </summary>
        public object EvaluateExpression(Expression expression)
        {
            return expression switch
            {
                NumericExpression num => EvaluateNumericExpression(num),
                StringExpression str => EvaluateStringExpression(str),
                BooleanExpression boolExpr => boolExpr.Value,
                IdentifierExpression id => EvaluateIdentifierExpression(id),
                UnaryExpression unary => EvaluateUnaryExpression(unary),
                NotExpression not => EvaluateNotExpression(not),
                BinaryExpression binary => EvaluateBinaryExpression(binary),
                LogicalExpression logical => EvaluateLogicalExpression(logical),
                ParenthesizedExpression paren => EvaluateExpression(paren.Expression),
                IncrementExpression inc => EvaluateIncrementExpression(inc),
                FunctionCallExpression call => EvaluateFunctionCall(call),
                ArrayAccessExpression arr => EvaluateArrayAccess(arr),
                ArrayLiteralExpression arrLit => EvaluateArrayLiteral(arrLit),
                MemberAccessExpression member => EvaluateMemberAccess(member),
                AddressOfExpression addr => EvaluateAddressOf(addr),
                DereferenceExpression deref => EvaluateDereference(deref),
                CompoundAssignmentExpression compound => EvaluateCompoundAssignmentExpression(compound),
                _ => null
            };
        }

        private object EvaluateNumericExpression(NumericExpression num)
        {
            return num.Number.Value;
        }

        private object EvaluateStringExpression(StringExpression str)
        {
            return str.StringValue.Value;
        }

        private object EvaluateIdentifierExpression(IdentifierExpression id)
        {
            return _scopeManager.GetVariableValue(
                id.Identifier.Text,
                id.Identifier.Line,
                id.Identifier.Column,
                _errors);
        }

        private object EvaluateUnaryExpression(UnaryExpression unary)
        {
            var operand = EvaluateExpression(unary.Operand);

            if (operand == null)
                return null;

            // Only unary minus
            if (unary.Operator.Type == TokenType.Minus)
            {
                if (operand is int i)
                    return -i;

                if (operand is double d)
                    return -d;

                _errors.Add(CompilationError.Semantic(
                    unary.Operator.Line, unary.Operator.Column,
                    $"unary minus operator cannot be applied to type {operand.GetType().Name}"));
            }

            return null;
        }

        private object EvaluateNotExpression(NotExpression not)
        {
            var operand = EvaluateExpression(not.Operand);

            if (operand == null)
                return null;

            return !IsTrue(operand);
        }

        private object EvaluateBinaryExpression(BinaryExpression binary)
        {
            var left = EvaluateExpression(binary.Left);
            var right = EvaluateExpression(binary.Right);

            if (left == null || right == null)
                return null;

            var op = binary.Operator;

            // Arithmetic operations
            if (op.IsArithmeticOperator())
            {
                if (op.Type == TokenType.Percent)
                {
                    return EvaluateModulo(left, right, op);
                }
                return EvaluateArithmeticOperation(left, op, right);
            }

            // Relational operations
            if (op.IsRelationalOperator())
            {
                return EvaluateRelationalOperation(left, op, right);
            }

            _errors.Add(CompilationError.Semantic(
                op.Line, op.Column,
                $"unknown operator '{op.Text}'"));

            return null;
        }

        /// <summary>
        /// Evaluates a logical expression with short-circuit evaluation.
        /// </summary>
        private object EvaluateLogicalExpression(LogicalExpression logical)
        {
            var left = EvaluateExpression(logical.Left);

            if (left == null)
                return null;

            bool leftBool = IsTrue(left);

            // Short-circuit evaluation
            if (logical.Operator.Type == TokenType.LogicalAnd)
            {
                // For &&: if left is false, return false without evaluating right
                if (!leftBool)
                    return false;

                var right = EvaluateExpression(logical.Right);
                return right != null && IsTrue(right);
            }
            else if (logical.Operator.Type == TokenType.LogicalOr)
            {
                // For ||: if left is true, return true without evaluating right
                if (leftBool)
                    return true;

                var right = EvaluateExpression(logical.Right);
                return right != null && IsTrue(right);
            }

            return null;
        }

        /// <summary>
        /// Evaluates an increment/decrement expression.
        /// </summary>
        private object EvaluateIncrementExpression(IncrementExpression inc)
        {
            var currentValue = _scopeManager.GetVariableValue(
                inc.Identifier.Text,
                inc.Identifier.Line,
                inc.Identifier.Column,
                _errors);

            if (currentValue == null)
                return null;

            object newValue;
            object returnValue;

            if (currentValue is int intVal)
            {
                newValue = inc.IsIncrement ? intVal + 1 : intVal - 1;
                returnValue = inc.IsPrefix ? newValue : intVal;
            }
            else if (currentValue is double doubleVal)
            {
                newValue = inc.IsIncrement ? doubleVal + 1.0 : doubleVal - 1.0;
                returnValue = inc.IsPrefix ? newValue : doubleVal;
            }
            else
            {
                _errors.Add(CompilationError.Semantic(
                    inc.Operator.Line, inc.Operator.Column,
                    $"increment/decrement can only be applied to numeric types"));
                return null;
            }

            // Update the variable
            _scopeManager.SetVariableValue(
                inc.Identifier.Text, newValue,
                inc.Identifier.Line, inc.Identifier.Column, _errors);

            return returnValue;
        }

        /// <summary>
        /// Evaluates a compound assignment expression and returns the new value.
        /// This allows compound assignments to be used in expressions like: int q = (p += 5) * 2;
        /// </summary>
        private object EvaluateCompoundAssignmentExpression(CompoundAssignmentExpression expr)
        {
            var currentValue = _scopeManager.GetVariableValue(
                expr.Identifier.Text, expr.Identifier.Line, expr.Identifier.Column, _errors);

            var rightValue = EvaluateExpression(expr.RightExpression);

            if (currentValue == null || rightValue == null)
                return null;

            object result = expr.Operator.Type switch
            {
                TokenType.PlusEqual => EvaluateArithmeticOperation(currentValue,
                    new Token(TokenType.Plus, "+", null, expr.Operator.Line, expr.Operator.Column, 0), rightValue),
                TokenType.MinusEqual => EvaluateArithmeticOperation(currentValue,
                    new Token(TokenType.Minus, "-", null, expr.Operator.Line, expr.Operator.Column, 0), rightValue),
                TokenType.StarEqual => EvaluateArithmeticOperation(currentValue,
                    new Token(TokenType.Star, "*", null, expr.Operator.Line, expr.Operator.Column, 0), rightValue),
                TokenType.SlashEqual => EvaluateArithmeticOperation(currentValue,
                    new Token(TokenType.Slash, "/", null, expr.Operator.Line, expr.Operator.Column, 0), rightValue),
                TokenType.PercentEqual => EvaluateModulo(currentValue, rightValue, expr.Operator),
                _ => null
            };

            if (result != null)
            {
                _scopeManager.SetVariableValue(
                    expr.Identifier.Text, result,
                    expr.Identifier.Line, expr.Identifier.Column, _errors);
            }

            return result;  // Return the new value so it can be used in expressions
        }

        /// <summary>
        /// Evaluates a function call.
        /// </summary>
        private object EvaluateFunctionCall(FunctionCallExpression call)
        {
            string funcName = call.FunctionName.Text;

            // Check for built-in functions
            if (IsBuiltInFunction(funcName))
            {
                return EvaluateBuiltInFunction(funcName, call);
            }

            // User-defined function
            if (_functions.TryGetValue(funcName, out var funcDecl))
            {
                return ExecuteUserFunction(funcDecl, call);
            }

            _errors.Add(CompilationError.Semantic(
                call.FunctionName.Line, call.FunctionName.Column,
                $"undefined function '{funcName}'"));

            return null;
        }

        /// <summary>
        /// Checks if a function is built-in.
        /// </summary>
        private bool IsBuiltInFunction(string name)
        {
            return name == "print" || name == "sqrt" || name == "abs" ||
                   name == "exp" || name == "log" || name == "sin" ||
                   name == "cos" || name == "tan" || name == "pow" ||
                   name == "min" || name == "max" || name == "floor" ||
                   name == "ceil" || name == "round" || name == "length" ||
                   name == "input" || name == "parseInt" || name == "parseDouble" ||
                   name == "toString" || name == "array" || name == "len";
        }

        /// <summary>
        /// Evaluates a built-in function (Flex & Bison style).
        /// </summary>
        private object EvaluateBuiltInFunction(string funcName, FunctionCallExpression call)
        {
            var args = new List<object>();
            foreach (var arg in call.Arguments)
            {
                var value = EvaluateExpression(arg);
                if (value != null)
                    args.Add(value);
            }

            try
            {
                return funcName switch
                {
                    "print" => ExecutePrintFunction(args),
                    "sqrt" => Math.Sqrt(ConvertToDouble(args[0])),
                    "abs" => args[0] is int i ? Math.Abs(i) : Math.Abs(ConvertToDouble(args[0])),
                    "exp" => Math.Exp(ConvertToDouble(args[0])),
                    "log" => Math.Log(ConvertToDouble(args[0])),
                    "sin" => Math.Sin(ConvertToDouble(args[0])),
                    "cos" => Math.Cos(ConvertToDouble(args[0])),
                    "tan" => Math.Tan(ConvertToDouble(args[0])),
                    "pow" => Math.Pow(ConvertToDouble(args[0]), ConvertToDouble(args[1])),
                    "min" => Math.Min(ConvertToDouble(args[0]), ConvertToDouble(args[1])),
                    "max" => Math.Max(ConvertToDouble(args[0]), ConvertToDouble(args[1])),
                    "floor" => Math.Floor(ConvertToDouble(args[0])),
                    "ceil" => Math.Ceiling(ConvertToDouble(args[0])),
                    "round" => Math.Round(ConvertToDouble(args[0])),
                    "length" => args[0] is string s ? s.Length : (args[0] is List<object> arr ? arr.Count : 0),
                    "len" => args[0] is string s2 ? s2.Length : (args[0] is List<object> arr2 ? arr2.Count : 0),
                    "input" => Console.ReadLine() ?? "",
                    "parseInt" => int.TryParse(args[0]?.ToString(), out int pi) ? pi : 0,
                    "parseDouble" => double.TryParse(args[0]?.ToString(), out double pd) ? pd : 0.0,
                    "toString" => args[0]?.ToString() ?? "",
                    "array" => CreateArray(args, call),
                    _ => null
                };
            }
            catch (Exception ex)
            {
                _errors.Add(CompilationError.Semantic(
                    call.FunctionName.Line, call.FunctionName.Column,
                    $"error calling function '{funcName}': {ex.Message}"));
                return null;
            }
        }

        /// <summary>
        /// Creates an array with the given size or elements.
        /// </summary>
        private List<object> CreateArray(List<object> args, FunctionCallExpression call)
        {
            if (args.Count == 0)
            {
                return new List<object>();
            }

            // If single int argument, create array of that size with nulls
            if (args.Count == 1 && args[0] is int size)
            {
                var arr = new List<object>(size);
                for (int i = 0; i < size; i++)
                {
                    arr.Add(0);
                }
                return arr;
            }

            // Otherwise, create array with the given elements
            return new List<object>(args);
        }

        /// <summary>
        /// Executes the print built-in function.
        /// </summary>
        private object ExecutePrintFunction(List<object> args)
        {
            if (args.Count > 0)
            {
                string output = FormatOutputValue(args[0]);
                _output.Add(output);
                Console.WriteLine(output);
            }
            return null;
        }

        /// <summary>
        /// Executes a user-defined function with proper scoping.
        /// Each function call gets its own scope, enabling recursion.
        /// </summary>
        private object ExecuteUserFunction(FunctionDeclaration func, FunctionCallExpression call)
        {
            // Check recursion depth
            if (_callDepth >= MAX_CALL_DEPTH)
            {
                _errors.Add(CompilationError.Semantic(
                    call.FunctionName.Line, call.FunctionName.Column,
                    $"maximum recursion depth ({MAX_CALL_DEPTH}) exceeded"));
                return null;
            }

            // Check argument count
            if (call.Arguments.Count != func.Parameters.Count)
            {
                _errors.Add(CompilationError.Semantic(
                    call.FunctionName.Line, call.FunctionName.Column,
                    $"function '{func.Name.Text}' expects {func.Parameters.Count} arguments, got {call.Arguments.Count}"));
                return null;
            }

            // Evaluate arguments BEFORE creating the new scope
            // This ensures arguments are evaluated in the caller's scope
            var argValues = new List<object>();
            for (int i = 0; i < call.Arguments.Count; i++)
            {
                argValues.Add(EvaluateExpression(call.Arguments[i]));
            }

            // Push a new function scope
            _scopeManager.PushFunctionScope(func.Name.Text);
            _callDepth++;

            try
            {
                // Declare and initialize parameters in the function scope
                for (int i = 0; i < func.Parameters.Count; i++)
                {
                    var param = func.Parameters[i];
                    var dataType = GetDataType(param.TypeKeyword.Type);
                    int paramLine = param.Identifier.Line;
                    int paramCol = param.Identifier.Column;

                    // Declare parameter in function scope
                    _scopeManager.DeclareVariable(
                        param.Identifier.Text,
                        dataType,
                        paramLine,
                        paramCol,
                        _errors);

                    // Set parameter value
                    if (argValues[i] != null)
                    {
                        var convertedValue = ConvertToType(argValues[i], dataType, paramLine, paramCol);
                        _scopeManager.SetVariableValue(
                            param.Identifier.Text,
                            convertedValue,
                            paramLine,
                            paramCol,
                            _errors);
                    }
                }

                // Execute function body (without pushing another scope)
                foreach (var stmt in func.Body.Statements)
                {
                    ExecuteStatement(stmt);
                }

                return null; // No explicit return
            }
            catch (ReturnException ret)
            {
                return ret.Value;
            }
            finally
            {
                // Pop the function scope
                _callDepth--;
                _scopeManager.PopScope();
            }
        }

        /// <summary>
        /// Evaluates an array access expression.
        /// </summary>
        private object EvaluateArrayAccess(ArrayAccessExpression arr)
        {
            var arrayValue = EvaluateExpression(arr.Array);
            var indexValue = EvaluateExpression(arr.Index);

            if (arrayValue == null)
            {
                _errors.Add(CompilationError.Semantic(
                    arr.OpenBracket.Line, arr.OpenBracket.Column,
                    "cannot access index of null value"));
                return null;
            }

            if (indexValue == null)
            {
                _errors.Add(CompilationError.Semantic(
                    arr.OpenBracket.Line, arr.OpenBracket.Column,
                    "array index cannot be null"));
                return null;
            }

            int index;
            if (indexValue is int i)
            {
                index = i;
            }
            else if (indexValue is double d)
            {
                index = (int)d;
            }
            else
            {
                _errors.Add(CompilationError.Semantic(
                    arr.OpenBracket.Line, arr.OpenBracket.Column,
                    "array index must be numeric"));
                return null;
            }

            // Handle string indexing
            if (arrayValue is string str)
            {
                if (index < 0 || index >= str.Length)
                {
                    _errors.Add(CompilationError.Semantic(
                        arr.OpenBracket.Line, arr.OpenBracket.Column,
                        $"string index {index} out of bounds (length: {str.Length})"));
                    return null;
                }
                return str[index].ToString();
            }

            // Handle array/list indexing
            if (arrayValue is List<object> list)
            {
                if (index < 0 || index >= list.Count)
                {
                    _errors.Add(CompilationError.Semantic(
                        arr.OpenBracket.Line, arr.OpenBracket.Column,
                        $"array index {index} out of bounds (length: {list.Count})"));
                    return null;
                }
                return list[index];
            }

            _errors.Add(CompilationError.Semantic(
                arr.OpenBracket.Line, arr.OpenBracket.Column,
                $"cannot index value of type {arrayValue.GetType().Name}"));
            return null;
        }

        /// <summary>
        /// Evaluates an array literal expression.
        /// </summary>
        private object EvaluateArrayLiteral(ArrayLiteralExpression arrLit)
        {
            var elements = new List<object>();
            foreach (var elem in arrLit.Elements)
            {
                elements.Add(EvaluateExpression(elem));
            }
            return elements;
        }

        /// <summary>
        /// Evaluates a member access expression (obj.member).
        /// </summary>
        private object EvaluateMemberAccess(MemberAccessExpression member)
        {
            var objValue = EvaluateExpression(member.Object);

            if (objValue == null)
            {
                _errors.Add(CompilationError.Semantic(
                    member.Dot.Line, member.Dot.Column,
                    "cannot access member of null value"));
                return null;
            }

            // Handle struct (Dictionary<string, object>)
            if (objValue is Dictionary<string, object> structValue)
            {
                string memberName = member.Member.Text;
                if (structValue.TryGetValue(memberName, out var value))
                {
                    return value;
                }
                _errors.Add(CompilationError.Semantic(
                    member.Member.Line, member.Member.Column,
                    $"struct has no member '{memberName}'"));
                return null;
            }

            // Handle array/list length property
            if (member.Member.Text == "length" || member.Member.Text == "Length")
            {
                if (objValue is List<object> arr)
                    return arr.Count;
                if (objValue is string str)
                    return str.Length;
            }

            _errors.Add(CompilationError.Semantic(
                member.Dot.Line, member.Dot.Column,
                $"cannot access member of type {objValue.GetType().Name}"));
            return null;
        }

        /// <summary>
        /// Evaluates an address-of expression (&amp;var).
        /// Returns a pointer (runtime representation).
        /// </summary>
        private object EvaluateAddressOf(AddressOfExpression addr)
        {
            // For simplicity, pointers are represented as a tuple (scope, name)
            // This is a basic implementation for educational purposes
            if (addr.Operand is IdentifierExpression id)
            {
                // Check that variable exists
                if (_scopeManager.VariableExists(id.Identifier.Text))
                {
                    return new PointerValue(id.Identifier.Text, _scopeManager);
                }
                _errors.Add(CompilationError.Semantic(
                    id.Identifier.Line, id.Identifier.Column,
                    $"cannot take address of undeclared variable '{id.Identifier.Text}'"));
            }
            else
            {
                _errors.Add(CompilationError.Semantic(
                    addr.Operator.Line, addr.Operator.Column,
                    "can only take address of variables"));
            }
            return null;
        }

        /// <summary>
        /// Evaluates a dereference expression (*ptr).
        /// </summary>
        private object EvaluateDereference(DereferenceExpression deref)
        {
            var ptrValue = EvaluateExpression(deref.Operand);

            if (ptrValue == null)
            {
                _errors.Add(CompilationError.Semantic(
                    deref.Operator.Line, deref.Operator.Column,
                    "cannot dereference null pointer"));
                return null;
            }

            if (ptrValue is PointerValue ptr)
            {
                return ptr.Dereference(_errors, deref.Operator.Line, deref.Operator.Column);
            }

            _errors.Add(CompilationError.Semantic(
                deref.Operator.Line, deref.Operator.Column,
                $"cannot dereference non-pointer value of type {ptrValue.GetType().Name}"));
            return null;
        }

        #endregion

        #region Arithmetic Operations

        private object EvaluateArithmeticOperation(object left, Token op, object right)
        {
            // STRING + STRING (concatenation)
            if (left is string str1 && right is string str2)
            {
                if (op.Type == TokenType.Plus)
                {
                    return str1 + str2;
                }

                _errors.Add(CompilationError.Semantic(
                    op.Line, op.Column,
                    $"operation '{op.Text}' is not supported for strings (only + for concatenation)"));
                return null;
            }

            // STRING with NUMBER - ERROR
            if (left is string || right is string)
            {
                _errors.Add(CompilationError.Semantic(
                    op.Line, op.Column,
                    "type mismatch: cannot combine string with number"));
                return null;
            }

            // INT op INT -> INT
            if (left is int i1 && right is int i2)
            {
                return op.Type switch
                {
                    TokenType.Plus => CheckedAdd(i1, i2, op),
                    TokenType.Minus => CheckedSubtract(i1, i2, op),
                    TokenType.Star => CheckedMultiply(i1, i2, op),
                    TokenType.Slash => DivideInt(i1, i2, op),
                    _ => null
                };
            }

            // DOUBLE op DOUBLE -> DOUBLE
            if (left is double d1 && right is double d2)
            {
                return op.Type switch
                {
                    TokenType.Plus => d1 + d2,
                    TokenType.Minus => d1 - d2,
                    TokenType.Star => d1 * d2,
                    TokenType.Slash => DivideDouble(d1, d2, op),
                    _ => null
                };
            }

            // INT op DOUBLE -> DOUBLE (implicit conversion)
            if (left is int ii && right is double dd)
            {
                return EvaluateArithmeticOperation((double)ii, op, dd);
            }

            if (left is double di && right is int iii)
            {
                return EvaluateArithmeticOperation(di, op, (double)iii);
            }

            _errors.Add(CompilationError.Semantic(
                op.Line, op.Column,
                $"type mismatch: {left?.GetType().Name ?? "null"} {op.Text} {right?.GetType().Name ?? "null"}"));

            return null;
        }

        private object EvaluateModulo(object left, object right, Token op)
        {
            if (left is int i1 && right is int i2)
            {
                if (i2 == 0)
                {
                    _errors.Add(CompilationError.Semantic(op.Line, op.Column, "modulo by zero"));
                    return null;
                }
                return i1 % i2;
            }

            if (IsNumber(left) && IsNumber(right))
            {
                double d1 = ConvertToDouble(left);
                double d2 = ConvertToDouble(right);
                if (Math.Abs(d2) < EPSILON)
                {
                    _errors.Add(CompilationError.Semantic(op.Line, op.Column, "modulo by zero"));
                    return null;
                }
                return d1 % d2;
            }

            _errors.Add(CompilationError.Semantic(
                op.Line, op.Column,
                "modulo operator requires numeric operands"));
            return null;
        }

        private object CheckedAdd(int a, int b, Token op)
        {
            try
            {
                return checked(a + b);
            }
            catch (OverflowException)
            {
                _errors.Add(CompilationError.Semantic(op.Line, op.Column, "integer addition overflow"));
                return null;
            }
        }

        private object CheckedSubtract(int a, int b, Token op)
        {
            try
            {
                return checked(a - b);
            }
            catch (OverflowException)
            {
                _errors.Add(CompilationError.Semantic(op.Line, op.Column, "integer subtraction overflow"));
                return null;
            }
        }

        private object CheckedMultiply(int a, int b, Token op)
        {
            try
            {
                return checked(a * b);
            }
            catch (OverflowException)
            {
                _errors.Add(CompilationError.Semantic(op.Line, op.Column, "integer multiplication overflow"));
                return null;
            }
        }

        private object DivideInt(int a, int b, Token op)
        {
            if (b == 0)
            {
                _errors.Add(CompilationError.Semantic(op.Line, op.Column, "division by zero"));
                return null;
            }
            return a / b;
        }

        private object DivideDouble(double a, double b, Token op)
        {
            if (Math.Abs(b) < EPSILON)
            {
                _errors.Add(CompilationError.Semantic(op.Line, op.Column, "division by zero"));
                return null;
            }
            return a / b;
        }

        #endregion

        #region Relational Operations

        private object EvaluateRelationalOperation(object left, Token op, object right)
        {
            // Comparisons only between numbers
            if (!IsNumber(left) || !IsNumber(right))
            {
                _errors.Add(CompilationError.Semantic(
                    op.Line, op.Column,
                    "relational operators can only be applied to numbers"));
                return null;
            }

            double val1 = ConvertToDouble(left);
            double val2 = ConvertToDouble(right);

            return op.Type switch
            {
                TokenType.LessThan => val1 < val2,
                TokenType.GreaterThan => val1 > val2,
                TokenType.LessThanOrEqual => val1 <= val2,
                TokenType.GreaterThanOrEqual => val1 >= val2,
                TokenType.EqualEqual => Math.Abs(val1 - val2) < EPSILON,
                TokenType.NotEqual => Math.Abs(val1 - val2) >= EPSILON,
                _ => null
            };
        }

        #endregion

        #region Helper Methods

        private bool IsNumber(object value)
        {
            return value is int || value is double;
        }

        private double ConvertToDouble(object value)
        {
            return value switch
            {
                int i => i,
                double d => d,
                _ => 0
            };
        }

        private bool IsTrue(object value)
        {
            if (value is bool b)
                return b;

            // For numbers: 0 = false, anything else = true
            if (value is int i)
                return i != 0;

            if (value is double d)
                return Math.Abs(d) >= EPSILON;

            // Non-null string is true
            if (value is string s)
                return !string.IsNullOrEmpty(s);

            // Non-empty array is true
            if (value is List<object> arr)
                return arr.Count > 0;

            return false;
        }

        private object ConvertToType(object value, DataType type, int line, int column)
        {
            if (value == null)
                return null;

            return type switch
            {
                DataType.Int when value is int => value,
                DataType.Int when value is double d => (int)d,
                DataType.Int when value is bool b => b ? 1 : 0,
                DataType.Double when value is double => value,
                DataType.Double when value is int i => (double)i,
                DataType.Double when value is bool b => b ? 1.0 : 0.0,
                DataType.String when value is string => value,
                DataType.String => value.ToString(),
                DataType.Bool when value is bool => value,
                DataType.Bool when IsNumber(value) => IsTrue(value),
                DataType.Array => value,  // Arrays pass through
                DataType.Pointer => value,  // Pointers pass through
                _ => ReturnConversionError(value, type, line, column)
            };
        }

        private object ReturnConversionError(object value, DataType type, int line, int column)
        {
            _errors.Add(CompilationError.Semantic(
                line, column,
                $"cannot convert {value?.GetType().Name ?? "null"} to {type}"));
            return null;
        }

        private string FormatValue(object value)
        {
            if (value is string str)
                return $"\"{str}\"";

            if (value is bool b)
                return b ? "true" : "false";

            if (value is List<object> arr)
                return FormatArray(arr);

            return value?.ToString() ?? "null";
        }

        private string FormatOutputValue(object value)
        {
            if (value is string str)
                return str;  // Don't add quotes for print

            if (value is bool b)
                return b ? "true" : "false";

            if (value is double d)
                return d.ToString(System.Globalization.CultureInfo.InvariantCulture);

            if (value is List<object> arr)
                return FormatArray(arr);

            return value?.ToString() ?? "null";
        }

        private string FormatArray(List<object> arr)
        {
            var elements = new List<string>();
            foreach (var elem in arr)
            {
                elements.Add(FormatValue(elem));
            }
            return "[" + string.Join(", ", elements) + "]";
        }

        private DataType GetDataType(TokenType tokenType)
        {
            return tokenType switch
            {
                TokenType.KeywordInt => DataType.Int,
                TokenType.KeywordDouble => DataType.Double,
                TokenType.KeywordString => DataType.String,
                TokenType.KeywordBool => DataType.Bool,
                TokenType.KeywordVoid => DataType.Void,
                TokenType.KeywordArray => DataType.Array,
                TokenType.KeywordPointer => DataType.Pointer,
                TokenType.KeywordStruct => DataType.Struct,
                _ => DataType.Unknown
            };
        }

        #endregion
    }

    /// <summary>
    /// Runtime representation of a pointer value.
    /// Points to a variable by name in a specific scope context.
    /// </summary>
    public class PointerValue
    {
        private readonly string _variableName;
        private readonly ScopeManager _scopeManager;

        public PointerValue(string variableName, ScopeManager scopeManager)
        {
            _variableName = variableName;
            _scopeManager = scopeManager;
        }

        public string VariableName => _variableName;

        /// <summary>
        /// Dereferences the pointer to get the pointed-to value.
        /// </summary>
        public object Dereference(List<CompilationError> errors, int line, int column)
        {
            return _scopeManager.GetVariableValue(_variableName, line, column, errors);
        }

        /// <summary>
        /// Sets the value at the pointed-to location.
        /// </summary>
        public bool SetValue(object value, List<CompilationError> errors, int line, int column)
        {
            return _scopeManager.SetVariableValue(_variableName, value, line, column, errors);
        }

        public override string ToString()
        {
            return $"*{_variableName}";
        }
    }

    /// <summary>
    /// Runtime representation of a struct value.
    /// Stores fields as key-value pairs.
    /// </summary>
    public class StructValue : Dictionary<string, object>
    {
        public string TypeName { get; }

        public StructValue(string typeName) : base()
        {
            TypeName = typeName;
        }

        public override string ToString()
        {
            var fields = new List<string>();
            foreach (var kvp in this)
            {
                fields.Add($"{kvp.Key}: {kvp.Value}");
            }
            return $"{TypeName} {{ {string.Join(", ", fields)} }}";
        }
    }
}
